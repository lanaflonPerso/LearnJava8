package com.trl.stream_api;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Stream;

public class ExampleOptional {
    public static void main(String[] args) throws IOException {
//---------------------------------------------------------------------------------------------------------------------
        String contents = new String(Files.readAllBytes(
                Paths.get("src/main/resources/StreamArchivos/alice30M")), StandardCharsets.UTF_8);
        List<String> wordList = Arrays.asList(contents.split("\\PL+"));
//        System.out.println(wordList);

        Optional<String> optionalValue = wordList.stream()
                .filter(s -> s.contains("fred"))
                .findFirst();
        System.out.println(optionalValue.orElse("No word") + " contains fred");
        //В приведенных nuze примерах было показано, как получить альтернативный вариант, если значение отсутствует.
        /*До сих пор обсуждалось, как употреблять объект типа Optional, созданный кем-то другим. Если же требуется написать
        метод, создающий объект типа Optional, то для этой цели имеется несколько статических методов. В приведенном ниже
        примере демонстрируется применение двух таких методов: Optional.of(result) и Optional.empty().*/
        Optional<String> optionalString = Optional.empty();
        String result = optionalString.orElse("N/A");
        System.out.println("result: " + result);
        result = optionalString.orElseGet(() -> Locale.getDefault().getDisplayName());
        System.out.println("result: " + result);
        try {
            /*А с другой стороны, в отсутствие значения можно сгенерировать исключение таким образом:*/
            result = optionalString.orElseThrow(IllegalStateException::new);
            System.out.println("result: " + result);
        } catch (Throwable t) {
            t.printStackTrace();
        }
        // Другая методика обращения с необязательными значениями состоит в том, чтобы употребить значение, если только
        // оно присутствует. Метод ifPresent() принимает функцию в качестве аргумента, как показано ниже. Если необязательное
        // значение существует, оно передается данной функции. В противном случае ничего не происходит.
        optionalValue = wordList.stream()
                .filter(s -> s.contains("red"))
                .findFirst();
        optionalValue.ifPresent(s -> System.out.println(s + " contains red"));
        /*Так, если требуется ввести значение во множество, при условии, что оно существует, достаточно сделать следующий вызов:
                                optionalValue.ifPresent(v -> results.add(v));
          или просто
                                optionalValue.ifPresent(results::add);*/
        Set<String> results = new HashSet<>();
        optionalValue.ifPresent(results::add);
        /*В результате вызова метода ifPresent() передаваемая ему функция никакого значения не возвращает. Если же требуется
        обработать результат выполнения функции, следует вызвать метод шар (), как показано ниже. В итоге переменная
        added будет содержать одно из следующих трех значений: логическое значение true или false, заключенное в оболочку
        типа Optional, если необязательно значение optionalValue присутствовало, а иначе — пустое значение типа Optional.*/
        Optional<Boolean> added = optionalValue.map(results::add);
        /*НА ЗАМЕТКУ! Метод map() служит аналогом метода mар() из интерфейса Stream, упоминавшегося в разделе 1.3. Необязательное
        значение можно рассматривать в качестве потока данных нулевой или единичной длины. Получаемый в итоге результат
        также имеет нулевую или единичную длину. И в последнем случае применялась функция.*/
        System.out.println(added);
        /*	Сочетание функций необязательных значений с методом fiatMap() Допустим, имеется метод fArgInt(), возвращающий объект
        типа Optional<T>, а у целевого типа Т — метод g(), возвращающий объект типа Optional<U>. Если бы это были обычные
        методы, их можно было бы составить в вызов s.fArgInt().g(). Нотакое сочетание не годится, поскольку результат вызова s.fArgInt()
        относится к типу Optional<T>, а не к типу Т. Вместо этого нужно сделать следующий вызов:
                            Optional<U> result = s.fArgInt().flatMap(Т::g);
        Если объект, получаемый в результате вызова s.fArgInt(), присутствует, то к нему применяется метод g(). В противном
        случае возвращается пустой объект типа Optional<U>. Очевидно, что данный процесс можно повторить, если имеются
        другие методы или лямбда-выражения, возвращающие необязательные значения типа Optional. В таком случае из них можно
        составить конвейер, связав их вызовы в цепочку с методом flatMap (), который будет успешно завершен, если завершатся
        все остальные части конвейера. В качестве примера рассмотрим надежный метод inverse () из предыдущего раздела.
        Допустим, имеется также следующий надежный метод для извлечения квадратного корня:
                            public static Optional<Double> squareRoot(Double x) {
                                    return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x));}
        В таком случае извлечь квадратный корень из значения, возвращаемого методом inverse(), можно следующим образом:
                            Optional<Double> result = inverse(х).flatMap(MyMath::squareRoot);
        или таким способом, если он предпочтительнее:
                            Optional<Double> result =
                                    Optional.of(-4.0).flatMap(Demo::inverse).flatMap(Demo::squareRoot) ;
        Если метод inverse() или squareRoot() возвратит результат вызова метода Optional.empty(), то конечный результат
        окажется пустым.
        НА ЗАМЕТКУ! Как было показано в разделе 1.3, метод flatMap () из интерфейса stream служит для составления двух других
        методов, получающих потоки данных, сводя их в результирующий поток потоков. Аналогичным образом действует и метод
        Optional. flatMap(), если необязательное значение интерпретируется как поток данных нулевой или единичной длины.*/
        System.out.println(inverse(4.0).flatMap(ExampleOptional::squareRoot));
        System.out.println(inverse(-1.0).flatMap(ExampleOptional::squareRoot));
        System.out.println(inverse(0.0).flatMap(ExampleOptional::squareRoot));
        Optional<Double> result2 = Optional.of(-4.0)
                .flatMap(ExampleOptional::inverse).flatMap(ExampleOptional::squareRoot);
        System.out.println(result2);

        /*Метод ofNullablef) служит в качестве моста между возможными пустыми (null) и необязательными (Optional) значениями.
        Так, при вызове метода Optional.ofNullable (obj ) возвращается результат вызова метода Optional.of(obj), если объект
        obj не является пустым (null), а иначе — результат вызова метода Optional.empty ().*/
        String valueNull = null;
        String value = "";
        Optional<String> optionalS = Optional.of(value);
        Optional<String> optionalS1 = Optional.ofNullable(valueNull);
//--------------------------------------------------------------------------------------------------------------------
        /*Нередко имеется значение, возможно, пустая строка " ”, которое требуется использовать по умолчанию в отсутствие совпадения:*/
        String resultA = optionalString.orElse ("");
        // Заключенная в оболочку строка, а в ее отсутствие - пустая строка ""

        /*Кроме того, можно вызвать функцию для вычисления значения по умолчанию следующим образом:*/
        String resultB = optionalString.orElseGet(() -> System.getProperty("user.dir"));
        // Функция вызывается только по мере надобности
//--------------------------------------------------------------------------------------------------------------------
        // Monada
        Optional<Integer> sum01 = Stream.iterate(1, k -> k + 1).
                parallel().
                limit(0).
                reduce((x, y) -> x - y);
        System.out.println("sum01 = " + sum01);
//---------------------------------------------------------------------------------------------------------------------
        Optional<Integer> sum02 = Stream.iterate(1, k -> k + 1).
                parallel().
                limit(10).
                reduce((x, y) -> x + y);
        System.out.println("sum02 = " + sum02);
//---------------------------------------------------------------------------------------------------------------------
        Optional<Integer> sum03 = Stream.iterate(1, k -> k + 1).
                parallel().
                limit(10).
                reduce((x, y) -> x - y);  // out 5
        System.out.println("sum03 = " + sum03);
//---------------------------------------------------------------------------------------------------------------------
        Optional<Integer> sum04 = Stream.iterate(1, k -> k + 1).
//            parallel().
        limit(10).
                        reduce((x, y) -> x - y);
        System.out.println("sum04 = " + sum04);
//---------------------------------------------------------------------------------------------------------------------
        // Demonstrate Optional<T>.
        Optional<String> noVal = Optional.empty();

        Optional<String> hasVal = Optional.of("ABCDEFG");

        if(noVal.isPresent()) System.out.println("This won't be displayed");
        else System.out.println("noVal has no value");

        if(hasVal.isPresent()) System.out.println("The string in hasVal is: " + hasVal.get());

        String defStr = noVal.orElse("Default String");
//        String defStr = noVal.toString();
//        String defStr = null;
        System.out.println(defStr);
//--------------------------------------------------------------------------------------------------------------------
    }

    public static Optional<Double> inverse(Double x) {
        return x == 0 ? Optional.empty() : Optional.of(1 / x);
    }

    public static Optional<Double> squareRoot(Double x) {
        return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x));
    }
}

/*
-----------------------------------------------------------------------------------------------------------------------
Объект типа Optional<T> служит оболочкой для объекта обобщенного типа Т или же ни для одного из объектов. В первом
случае считается, что значение присутствует. Тип Optional<T> служит в качестве более надежной альтернативы ссылке на
обобщенный тип Т, которая делается на объект или оказывается пустой. Но этот тип надежнее, если правильно им пользоваться.
-----------------------------------------------------------------------------------------------------------------------
В версииJDК 8 внедрены классы ОрtiоnаlDоuЫе, Optionallnt и OptionalLong,предосгавляющие изящный выход из положения в тех
случаях, когда значение может отсутствовать. В прошлом для того чтобы обозначить отсутствие значения, обычно использовалось
пустое значение nul l , но это могло привести к исключениям в связи с пустыми указателями при попытке разыменовать пустую
ссылку. Поэтому в о избежание подобных исключений требовались часть1е проверки на наличие пустого значения nul1. Классы,
рассматриваемые в этом разделе, предоставляют более удобный способ разрешить данное затруднение.Первыми самым общим из них
является класс Opt iona l . Поэтому именно ему и уделяется основное внимание в этом разделе. Ниже приведена общая форма его
объявления. class Optional<T> Здесь Т обозначает тип сохраняемого значения. Следует иметь в виду, что экземпляр класса Optional
может содержать значение типа т или быть пустым. Иными словами, объект типа Optional совсем не обязательно должен содержать
значение У класса Optional вообще отсугствуют конструкторы, но в нем определяется ряд методов для обращения с объектами
данного класса. С их помощью можно,например, определить наличие значения, получить значение, если оно присугствует, а если
оно отсугствует - значение по умолчанию, и даже создать значение типа Optional.
------------------------------Как не следует обращаться с необязательными значениями-----------------------------------
Если необязательные значения типа Optional не применяются правильно, то они не дают никаких преимуществ по сравнению с
прежним подходом, предоставлявшим выбор между чем-то существующим или несуществующим, т.е. null. Метод get() получает
заключенный в оболочку элемент значения типа Optional, если это значение существует, а иначе — он генерирует исключение
типа NoSuchElementException. Таким образом, следующий фрагмент кода:
                Optional<T> optionalValue = ...;
                optionalValue.get().someMethod()
не надежнее, чем такой код:
                Т value = ...;
                value.someMethod();
Метод isPresentf() извещает, содержит ли значение объект типа Optional<T>. Но выражение
                if (optionalValue.isPresent()) optionalValue.get(). someMethod () ;
не проще, чем выражение
                if (value != null) value.someMethod();
----------------------------------------------------------------------------------------------------------------------
Аналоmчным образом действуют классы Opt i onal DouЫe, Optiona l lnt
и OptionalLong, за исключением того что они специально предназначены для об­
работки значений типа douЫe, int и long соответствен но. И для этой цели вм есто
метода get ( ) в них определены методы getAsDouЬle ( ) , getAs In t ( ) и ge tAsLong ( )
с оответстве н но. Но в то же время в них не поддержи ваются методы filter ( ) ,
ofNullaЫe ( ) , rnap ( ) и flatMap ( ) .
----------------------------------------------------------------------------------------------------------------------
Понять принцип действия класса Op t i on a l лучше всего на конкретном при·
мере, в котором демонстрируется применение основных методов этого класса.
Основными в классе Opt i on a l являются классы i s P r e s e n t ( ) и g e t ( ) . Для того
чтобы выяснить, присутствует ли в экземпляре класса Op t i ona l значение, доста·
точно вызвать метод i s P r e s e n t ( ) Если значение присутствует, этот метод воз­
вращает логическое значение t rue , а иначе - логическое значение fa l s e . Итак,
если значение присутствует в экземпляре класса Op t i o n a l , его можно получить,
вызвав метод g e t ( ) . Но если вызвать метод g e t ( ) для объекта, не содержащего
значение, то генерируется исключение типа NoSuchE l eme n t E x c ep t i on. И м е н н о
поэтому следует сначала убедиться в наличии значения, а затем вызывать м ет о д
g e t ( ) для объекта типа Op t i on a l .
Безусловно, необходимость вызывать два метода для получения искомого зн а·
чения влечет за собой дополнительные издержки на доступ к этому значению.
Правда, в классе Op t i o n a l определяются методы, сочетающие в себе функции про­
верки и извлечения искомого значения. Одним из них является метод o r E l s e ( ) .
Так, если объект, для которого этот метод вызывается, содержит значение, то воз·
вращается именно оно, а иначе - значение по умолчанию.
Как упоминалось выше, в классе Ор t i ona 1 конструкторы не определены. Вместо
этого для создания экземпляра данного класса вызываются его методы. Например.
создать экземпляр класса Op t i ona l , содержащий конкретное значение, можно,
вызвав метод o fArgInt ( ) . А для того чтобы создать экземпляр класса Op t i ona l , не содер­
жащий конкретное значение, достаточно вызвать метод emp t y ( ) .
----------------------------------------------------------------------------------------------------------------------
• T orElse(T other)
    Возвращает присутствующее значение типа Optional или другое значение other, если присутствующее значение типа Optional
    оказывается пустым.

• Т orElseGet (Supplier<? extends Т> other)
    Возвращает присутствующее значение типа Optional или результат вызова функции othег(), если присутствующее значение
    типа Optional оказывается пустым.

• <Х extends Throwable> Т orElseThrow(Supplier<? extends X>exceptionSvpplier)
    Возвращает присутствующее значение типа Optional или результат вызова функции ехceptionSvpplier(), если присутствующее
    значение типа Optional оказывается пустым.

• void ifPresent(Consumer<? super T> consumer)
    Передает присутствующее значение типа Optional функции consvmerO, если это значение оказывается непустым.

• <U> Optional<U> map(Function<? super T,? extends U> mapper)
    Возвращает результат передачи присутствующего значения типа Optional функции mарреr(), если это значение оказывается
    непустым и результат не равен null, а иначе — пустое значение типа Optional.

• T get()
    Возвращает присутствующее значение типа Optional или генерирует исключение типа NoSuchElementException, если это
    значение оказывается пустым.

• boolean isPresent()
    Возвращает логическое значение true, если присутствующее значение типа Optional оказывается непустым.

• static <T> Optional<T> of (T value)
• static <T> Qptional<T> ofNullable(T value)
    Возвращают результат типа Optional с заданным значением. Если заданное значение value равно null, то первый метод
    генерирует исключение типа NullPointerException, а второй метод возвращает пустое значение типа Optional.

• static <Т> Optional<T> empty()
    Возвращает пустое значение типа Optional.

• <U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper)
    Возвращает результат применения функции mapper() к присутствующему значению типа Optional или же пустое значение типа
    Optional, если присутствующее значение типа Optional оказывается пустым.
----------------------------------------------------------------------------------------------------------------------
static <Т> Optiona1<Т> upty ( ) Возвращает объект, для которого метод isPresent ( )
возвращает логическое значение fa1se
Ьoolean equals (Сlфюt Возвращает логическое значение true, если вызыва­
ющий объект равен объекту, определяемому параме­
тром необязате.льн6lй, а иначе - логическое значение
нrобR3ате.лъный)
false
Opti o na1<Т> fil ter ( Predicate<?
super Т> .)'CIUIOШ1)
Возвращает зкземпляр класса Optional, содержащий
такое же значение, как и у вызывающего объекта,
если это значение удовлетворяет заданному условию,
а иначе - пустой объект
U
Optiona1<0> flatмap (Function<? П рименяет заданную отображлющую_фуюсцию к вы­
super Т , Optiona1<0>>
зывающему объекту, если этот объект содержит зна­
uтображающая_фующия>
чение, и возвращает полученный результат, а иначе -
пустой объект
т
get ( )
Возвращает значение в вызывающем объекте. Но
если в нем отсутствует значение, то генерируется ис­
ключение типа NоSuсhЕ18D18ntЕхоерtiоn
int hashCode ( ) Возвращает хеш-код вызывающего объекта
void ifPresent (ConsW11&r<?
super Т> фуюсция> Вызывает заданную фующию, если в вызывающем
объекте присутствует значение, передавая этот объ­
ект вызываемой фующии. В отсутствие значения ни­
каких действий не производится
Ьoolean isPresent ( ) Возвращает логическое значение true, если вызы­
вающий объект содержит значение, а в отсутствие
значения - логическое значение fArgInt'а1ве
u
Optiona1<0> map (Function<?
super Т , ? extenda U>>
uтобража _ ющая фующия)
Применяет заданную ото6раж.а юцrую_ фующ ию к вы­
зывающему объекту, если этот объект содержит зна­
чение, и возвращает полученный результат, а иначе -
пустой объект
static <Т> Optional<Т>
of (Т значе�ше)
Описание
Создает экземпляр класса Optional, содержащий за·
данное зна'tеНие и возвращает полученный результат.
Заданное значение не должно быть пустым (null)
static <Т> Optional<Т>
ofNullaЬle (Т значение) Создает экземпляр класса Optional, содержащий за·
данное значение и возвращает полученный результат.
Но если значение задано пустым, то возвращается пу·
стой экземпляр класса Optional
Т orElse (Т определяюще _ е значен ие) Если вызывающий объе�сr содержит значение,
то возвращается именно оно, а иначе - заданное
определяюще _значение
Т orElseGet ( Supplier<?
extend.8 Т> фyнкцUR_OOll)"UmUЯ ) Если вызывающий объе�сr содержит значение, то
возвращается именно оно, а иначе - значение, полу·
чаемое из заданной функции_тмучения
<Х
extends ТhrowaЬle> Т
orElseТhrow ( Suppl ier<?
extends Х> фунqия_шж.11ючения)
throws Х extends ТhrowaЬle
Stri.Dg toStri.nq ( )
Возвращает значение, содержащееся в вызывающем
объе�сrе. Но если такое значение отсугствует, то за­
данная ifiункц ия _ tиЖ.!IЮЧJ!НWI генерирует исключение
Возвращает строковое представление вызывающего
объекта
-----------------------------------------------------------------------------------------------------------------------
*/